const instanceOfAny=(object,constructors)=>constructors.some(c=>object instanceof c);let idbProxyableTypes,cursorAdvanceMethods;function getIdbProxyableTypes(){return idbProxyableTypes||(idbProxyableTypes=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function getCursorAdvanceMethods(){return cursorAdvanceMethods||(cursorAdvanceMethods=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const transactionDoneMap=new WeakMap,transformCache=new WeakMap,reverseTransformCache=new WeakMap;function promisifyRequest(request){const promise=new Promise((resolve,reject)=>{const unlisten=()=>{request.removeEventListener("success",success),request.removeEventListener("error",error)},success=()=>{resolve(wrap(request.result)),unlisten()},error=()=>{reject(request.error),unlisten()};request.addEventListener("success",success),request.addEventListener("error",error)});return reverseTransformCache.set(promise,request),promise}function cacheDonePromiseForTransaction(tx){if(transactionDoneMap.has(tx))return;const done=new Promise((resolve,reject)=>{const unlisten=()=>{tx.removeEventListener("complete",complete),tx.removeEventListener("error",error),tx.removeEventListener("abort",error)},complete=()=>{resolve(),unlisten()},error=()=>{reject(tx.error||new DOMException("AbortError","AbortError")),unlisten()};tx.addEventListener("complete",complete),tx.addEventListener("error",error),tx.addEventListener("abort",error)});transactionDoneMap.set(tx,done)}let idbProxyTraps={get(target,prop,receiver){if(target instanceof IDBTransaction){if(prop==="done")return transactionDoneMap.get(target);if(prop==="store")return receiver.objectStoreNames[1]?void 0:receiver.objectStore(receiver.objectStoreNames[0])}return wrap(target[prop])},set(target,prop,value){return target[prop]=value,!0},has(target,prop){return target instanceof IDBTransaction&&(prop==="done"||prop==="store")?!0:prop in target}};function replaceTraps(callback){idbProxyTraps=callback(idbProxyTraps)}function wrapFunction(func){return getCursorAdvanceMethods().includes(func)?function(...args){return func.apply(unwrap(this),args),wrap(this.request)}:function(...args){return wrap(func.apply(unwrap(this),args))}}function transformCachableValue(value){return typeof value=="function"?wrapFunction(value):(value instanceof IDBTransaction&&cacheDonePromiseForTransaction(value),instanceOfAny(value,getIdbProxyableTypes())?new Proxy(value,idbProxyTraps):value)}function wrap(value){if(value instanceof IDBRequest)return promisifyRequest(value);if(transformCache.has(value))return transformCache.get(value);const newValue=transformCachableValue(value);return newValue!==value&&(transformCache.set(value,newValue),reverseTransformCache.set(newValue,value)),newValue}const unwrap=value=>reverseTransformCache.get(value);function openDB(name,version,{blocked,upgrade,blocking,terminated}={}){const request=indexedDB.open(name,version),openPromise=wrap(request);return upgrade&&request.addEventListener("upgradeneeded",event=>{upgrade(wrap(request.result),event.oldVersion,event.newVersion,wrap(request.transaction),event)}),blocked&&request.addEventListener("blocked",event=>blocked(event.oldVersion,event.newVersion,event)),openPromise.then(db=>{terminated&&db.addEventListener("close",()=>terminated()),blocking&&db.addEventListener("versionchange",event=>blocking(event.oldVersion,event.newVersion,event))}).catch(()=>{}),openPromise}const readMethods=["get","getKey","getAll","getAllKeys","count"],writeMethods=["put","add","delete","clear"],cachedMethods=new Map;function getMethod(target,prop){if(!(target instanceof IDBDatabase&&!(prop in target)&&typeof prop=="string"))return;if(cachedMethods.get(prop))return cachedMethods.get(prop);const targetFuncName=prop.replace(/FromIndex$/,""),useIndex=prop!==targetFuncName,isWrite=writeMethods.includes(targetFuncName);if(!(targetFuncName in(useIndex?IDBIndex:IDBObjectStore).prototype)||!(isWrite||readMethods.includes(targetFuncName)))return;const method=async function(storeName,...args){const tx=this.transaction(storeName,isWrite?"readwrite":"readonly");let target2=tx.store;return useIndex&&(target2=target2.index(args.shift())),(await Promise.all([target2[targetFuncName](...args),isWrite&&tx.done]))[0]};return cachedMethods.set(prop,method),method}replaceTraps(oldTraps=>({...oldTraps,get:(target,prop,receiver)=>getMethod(target,prop)||oldTraps.get(target,prop,receiver),has:(target,prop)=>!!getMethod(target,prop)||oldTraps.has(target,prop)}));const advanceMethodProps=["continue","continuePrimaryKey","advance"],methodMap={},advanceResults=new WeakMap,ittrProxiedCursorToOriginalProxy=new WeakMap,cursorIteratorTraps={get(target,prop){if(!advanceMethodProps.includes(prop))return target[prop];let cachedFunc=methodMap[prop];return cachedFunc||(cachedFunc=methodMap[prop]=function(...args){advanceResults.set(this,ittrProxiedCursorToOriginalProxy.get(this)[prop](...args))}),cachedFunc}};async function*iterate(...args){let cursor=this;if(cursor instanceof IDBCursor||(cursor=await cursor.openCursor(...args)),!cursor)return;cursor=cursor;const proxiedCursor=new Proxy(cursor,cursorIteratorTraps);for(ittrProxiedCursorToOriginalProxy.set(proxiedCursor,cursor),reverseTransformCache.set(proxiedCursor,unwrap(cursor));cursor;)yield proxiedCursor,cursor=await(advanceResults.get(proxiedCursor)||cursor.continue()),advanceResults.delete(proxiedCursor)}function isIteratorProp(target,prop){return prop===Symbol.asyncIterator&&instanceOfAny(target,[IDBIndex,IDBObjectStore,IDBCursor])||prop==="iterate"&&instanceOfAny(target,[IDBIndex,IDBObjectStore])}replaceTraps(oldTraps=>({...oldTraps,get(target,prop,receiver){return isIteratorProp(target,prop)?iterate:oldTraps.get(target,prop,receiver)},has(target,prop){return isIteratorProp(target,prop)||oldTraps.has(target,prop)}}));export{openDB as o};
